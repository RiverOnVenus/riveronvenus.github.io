<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://zhui.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://zhui.dev/" rel="alternate" type="text/html" /><updated>2024-12-15T14:36:22+08:00</updated><id>https://zhui.dev/feed.xml</id><title type="html">Error: 你发现了一个错误！</title><subtitle>Life often requires some excitement, joy, and anticipation.</subtitle><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><entry><title type="html">SDDM 主题导致登录程序黑屏</title><link href="https://zhui.dev/2024-12/login-program-black-screen-caused-by-sddm-theme" rel="alternate" type="text/html" title="SDDM 主题导致登录程序黑屏" /><published>2024-12-15T00:00:00+08:00</published><updated>2024-12-15T00:00:00+08:00</updated><id>https://zhui.dev/2024-12/login-program-black-screen-caused-by-sddm-theme</id><content type="html" xml:base="https://zhui.dev/2024-12/login-program-black-screen-caused-by-sddm-theme"><![CDATA[<p>这天我打开电脑发现开机后屏幕黑屏，只有鼠标光标可见，登录界面没有显示。看着唯一的光标我开始思考上次做了什么——想不起来了～</p>

<p>我尝试在终端中执行 <code class="language-plaintext highlighter-rouge">startplasma-wayland</code>，发现能够正常进入桌面。这表明桌面环境本身是正常的，问题可能出在登录管理器上。</p>

<p>开始查看日志，发现 sddm 在加载主题的时候有问题。</p>

<p><a data-fancybox="image" href="https://image.zhui.dev/file/1734183422289_image.png"><img src="https://image.zhui.dev/file/1734183422289_image.png" /></a></p>

<p>看了下配置文件，的确配置了「plasma-chili」</p>

<p><a data-fancybox="image" href="https://image.zhui.dev/file/1734183307596_image.png"><img src="https://image.zhui.dev/file/1734183307596_image.png" /></a></p>

<p>思考，我什么时候把「微风」改了:thinking:</p>

<p>改回 Current=breeze 重启，熟悉的「微风」回来了。应该是因为「<a href="http://store.kde.org/p/1214121/">plasma-chili</a>」是基于 plasma5 做的主题，导致了这个问题。</p>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="linux" /><summary type="html"><![CDATA[这天我打开电脑发现开机后屏幕黑屏，只有鼠标光标可见，登录界面没有显示。看着唯一的光标我开始思考上次做了什么——想不起来了～]]></summary></entry><entry><title type="html">Meow~</title><link href="https://zhui.dev/2024-11/cat-photos" rel="alternate" type="text/html" title="Meow~" /><published>2024-11-04T00:00:00+08:00</published><updated>2024-11-04T00:00:00+08:00</updated><id>https://zhui.dev/2024-11/cat-photos</id><content type="html" xml:base="https://zhui.dev/2024-11/cat-photos"><![CDATA[<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074210182_1730732509302.jpg"><img src="https://image.zhui.dev/file/1731074210182_1730732509302.jpg" /></a></p>

<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074248031_1730731750717.jpg"><img src="https://image.zhui.dev/file/1731074248031_1730731750717.jpg" /></a></p>

<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074218990_1730815360985.jpg"><img src="https://image.zhui.dev/file/1731074218990_1730815360985.jpg" /></a></p>

<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074214964_1730732111768.jpg"><img src="https://image.zhui.dev/file/1731074214964_1730732111768.jpg" /></a></p>

<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074210352_1730732318365.jpg"><img src="https://image.zhui.dev/file/1731074210352_1730732318365.jpg" /></a></p>

<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074205605_1730732060880.jpg"><img src="https://image.zhui.dev/file/1731074205605_1730732060880.jpg" /></a></p>

<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074218456_1730815404970.jpg"><img src="https://image.zhui.dev/file/1731074218456_1730815404970.jpg" /></a></p>

<p><a data-fancybox="cat-photos" href="https://image.zhui.dev/file/1731074246062_1730732347519.jpg"><img src="https://image.zhui.dev/file/1731074246062_1730732347519.jpg" /></a></p>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="misc" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">NVIDIA 导致系统挂起失败</title><link href="https://zhui.dev/2024-06/nvidia-fail-to-suspend" rel="alternate" type="text/html" title="NVIDIA 导致系统挂起失败" /><published>2024-06-23T00:00:00+08:00</published><updated>2024-06-23T00:00:00+08:00</updated><id>https://zhui.dev/2024-06/nvidia-fail-to-suspend</id><content type="html" xml:base="https://zhui.dev/2024-06/nvidia-fail-to-suspend"><![CDATA[<ul id="markdown-toc">
  <li><a href="#现象" id="markdown-toc-现象">现象</a></li>
  <li><a href="#日志" id="markdown-toc-日志">日志</a></li>
  <li><a href="#解决" id="markdown-toc-解决">解决</a>    <ul>
      <li><a href="#错误的方法" id="markdown-toc-错误的方法">“错误的”方法</a></li>
      <li><a href="#正确的方法pushpin" id="markdown-toc-正确的方法pushpin">正确的方法:pushpin:</a></li>
    </ul>
  </li>
  <li><a href="#参考" id="markdown-toc-参考">参考</a></li>
</ul>
<h2 id="现象">现象</h2>

<p><code class="language-plaintext highlighter-rouge">systemctl suspend</code> 后系统立即被唤醒。</p>

<h2 id="日志">日志</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Jun 23 14:09:26 venus systemd[1]: Starting System Suspend...
Jun 23 14:09:26 venus systemd-sleep[2537]: User sessions remain unfrozen on explicit request ($SYSTEMD_SLEEP_FREEZE_USER_SESSIONS=0).
Jun 23 14:09:26 venus systemd-sleep[2537]: This is not recommended, and might result in unexpected behavior, particularly
Jun 23 14:09:26 venus systemd-sleep[2537]: in suspend-then-hibernate operations or setups with encrypted home directories.
Jun 23 14:09:26 venus systemd-sleep[2537]: Performing sleep operation 'suspend'...
Jun 23 14:09:28 venus systemd-sleep[2537]: Failed to put system to sleep. System resumed again: Input/output error
Jun 23 14:09:28 venus systemd[1]: systemd-suspend.service: Main process exited, code=exited, status=1/FAILURE
Jun 23 14:09:28 venus systemd[1]: systemd-suspend.service: Failed with result 'exit-code'.
Jun 23 14:09:28 venus systemd[1]: Failed to start System Suspend.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[   95.430308] nvidia 0000:01:00.0: PM: pci_pm_suspend(): nv_pmops_suspend+0x0/0x30 [nvidia] returns -5
[   95.430918] nvidia 0000:01:00.0: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x1b0 returns -5
[   95.430924] nvidia 0000:01:00.0: PM: failed to suspend async: error -5
[   97.195357] nvidia 0000:01:00.0: PM: pci_pm_suspend(): nv_pmops_suspend+0x0/0x30 [nvidia] returns -5
[   97.195930] nvidia 0000:01:00.0: PM: dpm_run_callback(): pci_pm_suspend+0x0/0x1b0 returns -5
[   97.195934] nvidia 0000:01:00.0: PM: failed to suspend async: error -5
</code></pre></div></div>

<h2 id="解决">解决</h2>

<h3 id="错误的方法">“错误的”方法</h3>

<p>在看到是 nvidia 导致的问题时，我立即想的是先禁用掉它，于是安装了 <a href="https://github.com/bayasdev/envycontrol">envycontrol</a> 切到 integrated 模式，有效。</p>

<p>但这不是正确的解决方法，所以卸载 envycontrol 并删除它的残留配置文件。</p>

<h3 id="正确的方法pushpin">正确的方法:pushpin:</h3>

<p>通过日志找到了 <a href="https://wiki.archlinux.org/title/Power_management/Wakeup_triggers#NVIDIA_drivers">Wakeup_triggers#NVIDIA_drivers</a>, 一模一样的日志，抄一抄 wiki 的解决方法。</p>

<p>先添加内核模块参数：<code class="language-plaintext highlighter-rouge">NVreg_PreserveVideoMemoryAllocations=1</code></p>

<p>再启用相关服务：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo systemctl enable nvidia-suspend.service
sudo systemctl enable nvidia-hibernate.service
sudo systemctl enable nvidia-resume.service
</code></pre></div></div>

<p>重启后挂起成功。</p>

<h2 id="参考">参考</h2>

<ol>
  <li><a href="https://wiki.archlinux.org/title/Power_management/Wakeup_triggers#NVIDIA_drivers">https://wiki.archlinux.org/title/Power_management/Wakeup_triggers#NVIDIA_drivers</a></li>
  <li><a href="https://wiki.archlinux.org/title/NVIDIA/Tips_and_tricks#Preserve_video_memory_after_suspend">https://wiki.archlinux.org/title/NVIDIA/Tips_and_tricks#Preserve_video_memory_after_suspend</a></li>
</ol>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="linux" /><summary type="html"><![CDATA[现象 日志 解决 “错误的”方法 正确的方法:pushpin: 参考 现象]]></summary></entry><entry><title type="html">TCP listen 的故事</title><link href="https://zhui.dev/2024-04/tcp-listen" rel="alternate" type="text/html" title="TCP listen 的故事" /><published>2024-04-16T00:00:00+08:00</published><updated>2024-04-16T00:00:00+08:00</updated><id>https://zhui.dev/2024-04/tcp-listen</id><content type="html" xml:base="https://zhui.dev/2024-04/tcp-listen"><![CDATA[<ul id="markdown-toc">
  <li><a href="#man-2-listen" id="markdown-toc-man-2-listen">man 2 listen</a></li>
  <li><a href="#两个队列和三次握手" id="markdown-toc-两个队列和三次握手">两个队列和三次握手</a>    <ul>
      <li><a href="#测试程序和抓包" id="markdown-toc-测试程序和抓包">测试程序和抓包</a></li>
    </ul>
  </li>
  <li><a href="#协议攻击" id="markdown-toc-协议攻击">协议攻击</a>    <ul>
      <li><a href="#对策" id="markdown-toc-对策">对策</a></li>
    </ul>
  </li>
  <li><a href="#参考资料" id="markdown-toc-参考资料">参考资料</a></li>
</ul>
<h2 id="man-2-listen">man 2 listen</h2>

<p>先从手册看看描述：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DESCRIPTION
       listen() marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be
       used to accept incoming connection requests using accept(2).

       The  sockfd  argument  is  a  file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQ‐
       PACKET.

       The backlog argument defines the maximum length to which the queue of pending connections  for  sockfd
       may  grow.   If  a  connection request arrives when the queue is full, the client may receive an error
       with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request
       may be ignored so that a later reattempt at connection succeeds.

</code></pre></div></div>

<p>从描述中可以知道，<code class="language-plaintext highlighter-rouge">listen()</code> 将 <code class="language-plaintext highlighter-rouge">sockfd</code> 引用的套接字标记为被动套接字，可以在上面调用 <code class="language-plaintext highlighter-rouge">accept()</code> 。</p>

<p>在后面的注意事项中有这样一段话：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NOTES
       The  behavior  of  the  backlog  argument on TCP sockets changed with Linux 2.2.  Now it specifies the
       queue length for completely established sockets waiting to be accepted, instead of the number  of  in‐
       complete connection requests.  The maximum length of the queue for incomplete sockets can be set using
       /proc/sys/net/ipv4/tcp_max_syn_backlog.   When  syncookies  are  enabled  there  is no logical maximum
       length and this setting is ignored.  See tcp(7) for more information.

       If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently
       capped to that value.  Since Linux 5.4, the default in this file is 4096; in earlier kernels, the  de‐
       fault value is 128.  Before Linux 2.4.25, this limit was a hard coded value, SOMAXCONN, with the value
       128.
</code></pre></div></div>

<p>这说明调用<code class="language-plaintext highlighter-rouge">listen()</code>时内核维护了两个队列 —— “未完全建立连接队列”和“完全建立连接队列”，也就是下文中的 syn queue 和 pending queue.</p>

<p>再回到函数原型：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
</code></pre></div></div>

<p>参数 <code class="language-plaintext highlighter-rouge">sockfd</code> 是一个已经创建的套接字描述符，而 <code class="language-plaintext highlighter-rouge">backlog</code> 则表示服务器端能够接受的完全建立的套接字连接队列的最大长度。</p>

<h2 id="两个队列和三次握手">两个队列和三次握手</h2>

<p>TCP 通信过程如下图：</p>

<p><a data-fancybox="tcp-listen" href="../assets/img/post/tcp-listen/tcp-socket.png"><img src="../assets/img/post/tcp-listen/tcp-socket.png" /></a></p>

<p>三次握手发生在系统调用 <code class="language-plaintext highlighter-rouge">connect()</code>,<code class="language-plaintext highlighter-rouge">listen()</code>阶段：</p>

<p><a data-fancybox="tcp-listen" href="../assets/img/post/tcp-listen/tcp-socket-3whs.png"><img src="../assets/img/post/tcp-listen/tcp-socket-3whs.png" /></a></p>

<ul>
  <li>syn queue - 用于存储 SYN_RECV 状态的连接</li>
  <li>pending queue - 用于存储 ESTABLISHED 状态的连接</li>
</ul>

<p>客户端调用 <code class="language-plaintext highlighter-rouge">connect()</code> 发起连接，发送了第一次握手的 SYN 包，服务器回了 SYN+ACK 包，此时的连接（SYN_RECV 状态）会放在 syn queue，服务器收到最后一个 ACK 包完成三次握手完成后的连接（ESTABLISHED 状态）放在 pending queue，等待 <code class="language-plaintext highlighter-rouge">accept()</code> 调用出队。</p>

<h3 id="测试程序和抓包">测试程序和抓包</h3>

<p>下面是一个验证 TCP 三次握手发生在<code class="language-plaintext highlighter-rouge">connect()</code>,<code class="language-plaintext highlighter-rouge">listen()</code>阶段的简单示例：</p>

<p>client.c</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strings.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"socket"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server_addr</span><span class="p">;</span>
  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>
  <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
  <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>

  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"connect"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"connected</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>server.c</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strings.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"socket"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server_addr</span><span class="p">;</span>
  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>
  <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
  <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>

  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"bind"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">ret</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="mi">33</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"listen"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 留给抓包的时间</span>
  <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>先运行 server</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ ./server 192.168.100.191 33333
</code></pre></div></div>

<p>再抓包</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ sudo tcpdump -i any port 33333
</code></pre></div></div>

<p>最后用 client 连接 server</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ ./client 192.168.100.191 33333
</code></pre></div></div>

<p>可以看到抓包的输出</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ sudo tcpdump -i any port 33333
tcpdump: data link type LINUX_SLL2
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes
15:17:50.191602 lo    In  IP venus.38172 &gt; venus.dgi-serv: Flags [SEW], seq 3952710686, win 33280, options [mss 65495,nop,nop,sackOK,nop,wscale 10], length 0
15:17:50.191625 lo    In  IP venus.dgi-serv &gt; venus.38172: Flags [S.E], seq 2291194089, ack 3952710687, win 33280, options [mss 65495,nop,nop,sackOK,nop,wscale 10], length 0
15:17:50.191652 lo    In  IP venus.38172 &gt; venus.dgi-serv: Flags [.], ack 1, win 33, length 0
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Flags [SEW]</code>: 表示这是一个 SYN 包，同时 ECE 和 CWR 标志位被置位。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags [S.E]</code>: 表示这是一个 SYN+ACK 包，同时 ECE 标志被置位。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags [.]</code>: 表示这是一个 ACK 包，客户端收到了服务器端的 SYN+ACK 包，并确认建立了连接。</li>
</ol>

<h2 id="协议攻击">协议攻击</h2>

<p>SYN 泛洪，在 DDoS 中属于 TCP 协议攻击，针对的是 syn queue.</p>

<h3 id="对策">对策</h3>

<p>增大 syn queue 最大长度：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net.ipv4.tcp_max_syn_backlog = 8192
</code></pre></div></div>

<p>相关阅读：</p>

<ul>
  <li><a href="https://www.cloudflare.com/learning/ddos/syn-flood-ddos-attack/">https://www.cloudflare.com/learning/ddos/syn-flood-ddos-attack</a></li>
  <li><a href="https://zh.wikipedia.org/wiki/SYN_flood">https://zh.wikipedia.org/wiki/SYN_flood</a></li>
  <li><a href="https://wiki.archlinux.org/title/Sysctl#Tweak_the_pending_connection_handling">https://wiki.archlinux.org/title/Sysctl#Tweak_the_pending_connection_handling</a></li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li>man 2 listen</li>
  <li><a href="https://stackoverflow.com/questions/12893379/listen-queue-length-in-socket-programing-in-c">https://stackoverflow.com/questions/12893379/listen-queue-length-in-socket-programing-in-c</a></li>
</ol>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="network" /><summary type="html"><![CDATA[man 2 listen 两个队列和三次握手 测试程序和抓包 协议攻击 对策 参考资料 man 2 listen]]></summary></entry><entry><title type="html">记录一次抓 TCP 三次握手</title><link href="https://zhui.dev/2024-03/capture-tcp-3-way-handshake" rel="alternate" type="text/html" title="记录一次抓 TCP 三次握手" /><published>2024-03-16T00:00:00+08:00</published><updated>2024-03-16T00:00:00+08:00</updated><id>https://zhui.dev/2024-03/capture-tcp-3-way-handshake</id><content type="html" xml:base="https://zhui.dev/2024-03/capture-tcp-3-way-handshake"><![CDATA[<ul id="markdown-toc">
  <li><a href="#前言" id="markdown-toc-前言">前言</a></li>
  <li><a href="#正文" id="markdown-toc-正文">正文</a>    <ul>
      <li><a href="#理论" id="markdown-toc-理论">理论</a></li>
      <li><a href="#实践" id="markdown-toc-实践">实践</a></li>
    </ul>
  </li>
  <li><a href="#参考资料" id="markdown-toc-参考资料">参考资料</a></li>
</ul>
<h2 id="前言">前言</h2>

<p>TCP 三次握手看过很多次了，当时也是理解了，但是总是忘记。比如这次，又忘了，所有来抓包加深记忆和理解，要是还忘了，就来这儿看看:joy:</p>

<p>抓包工具本来想试试 termshark 来着，因为没用过，但是中途内存泄漏被 earlyoom 杀死了，还是用 wireshark.</p>

<p><span class="spoiler">earlyoom 的通知怎么又好了（</span></p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/system-notify.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/system-notify.png" /></a></p>

<p>如果你也不喜欢 systemd-oomd 试试 <a href="https://github.com/rfjakob/earlyoom">earlyoom</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>earlyoom[454]: Will avoid killing process names that match regex '(^|/)(init|systemd|Xorg|sshd)$'
earlyoom[454]: mem total: 7721 MiB, swap total: 7720 MiB
earlyoom[454]: sending SIGTERM when mem &lt;= 10.00% and swap &lt;= 10.00%,
earlyoom[454]:         SIGKILL when mem &lt;=  5.00% and swap &lt;=  5.00%
earlyoom[454]: mem avail:  7072 of  7721 MiB (91.60%), swap free: 7720 of 7720 MiB (100.00%)
earlyoom[454]: mem avail:   554 of  7721 MiB ( 7.18%), swap free:  742 of 7720 MiB ( 9.62%)
earlyoom[454]: low memory! at or below SIGTERM limits: mem 10.00%, swap 10.00%
earlyoom[454]: sending SIGTERM to process 9994 uid 1000 "termshark": badness 1181, VmRSS 4568 MiB
earlyoom[454]: escalating to SIGKILL after 2.8 seconds
earlyoom[454]: process exited after 2.8 seconds

</code></pre></div></div>

<p>好像偏题了。</p>

<h2 id="正文">正文</h2>

<h3 id="理论">理论</h3>

<p>开始抓包，抓取的是本地访问博客产生的 TCP 数据包，下面的 NO.1343 – [SYN], NO.1344 – [SYN, ACK], NO.1345 – [ACK] 三个包分别对应三次握手的过程，</p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img01.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img01.png" /></a></p>

<p>先回忆一下 TCP 三次握手过程，简单画了个图：</p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img02.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img02.png" /></a></p>

<p>再看看 TCP 报文段头部格式：</p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img03.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img03.png" /></a></p>

<blockquote>
  <p>Screenshot from <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Wikipedia</a></p>
</blockquote>

<p>结合上面三张图分析 TCP 三次握手过程，然后分析抓包的数据：</p>

<ol>
  <li>[SYN]：客户端向服务器发送一个 SYN 包来发起主动连接，客户端将数据包的序列号 Seq 设置为一个随机数 x. 此时，标志位 SYN = 1, 序列号 Seq = x.</li>
  <li>[SYN, ACK]：服务器回应一个 [SYN, ACK] 包。确认号 Ack 被设置为接收到的序列号加 1，即 x + 1，服务器的数据包序列号 Seq 设置为另一个随机数 y。此时，标志位 SYN = 1, 标志位 ACK = 1, 确认号 Ack = x + 1, 序列号 Seq = y.</li>
  <li>[ACK]：最后，客户端向服务器发送一个 ACK 包。数据包的序列号 Seq 被设置为接收到的确认号 Ack，即 x + 1，确认号 Ack 被设置为接收到的序列号加 1，即 y + 1。此时，标志位 ACK = 1, 序列号 Seq = x + 1, 确认号 Ack = y + 1.</li>
</ol>

<p>为了更好的理解 TCP 三次握手作以下补充说明：</p>

<ul>
  <li>ACK 标志位 (Acknowledgment) 和 Ack 确认号字段 (Acknowledgment number) 不要混淆。在 TCP 协议中，”Acknowledgment (ACK)” 是 TCP 报文段头部的一个标志位，它用来表示一个 TCP 报文段是否包含“确认”。当 ACK 标志位被置为 1 时，表示该报文段确认了已经收到的数据。 “Acknowledgment Number” 是 TCP 报文段头部的一个字段，用来表示发送方期望接收到的下一个序列号。当一个 TCP 报文段被发送方设置了 ACK 标志位为 1 时，该报文段的 Acknowledgment Number 字段表明了发送方期望接收到的下一个序列号。</li>
  <li>抓包的时候可以看见 Ack = 1 (Ack 确认号)，这里的 1 是相对确认号，可以理解为偏移量，不是真正的确认号（相对序列号同理），也不要和 ACK = 1 (Acknowledgment) 混淆。本文中，全大写的 ACK 是标志位，首字母大写的 Ack 是确认号。</li>
  <li>下面的 Flags: (SYN), Flags: (SYN, ACK) 表示对应的标志位为 1.</li>
</ul>

<p>接下来逐包分析 [SYN]，[SYN, ACK]，[ACK] 三个包中的各个数据之间的关系是否和上述一致。</p>

<h3 id="实践">实践</h3>

<p>第一次握手：客户端 192.168.100.191 发送了一个 [SYN] 包给服务端 172.67.149.132，此时，Seq = 0x4ce45750, Flags: (SYN).</p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img04.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img04.png" /></a></p>

<p>第二次握手：服务端 172.67.149.132 收到 [SYN] 包，回应了一个 [SYN, ACK] 包给客户端 192.168.100.191，此时，Ack = 0x4ce45751, Seq = 0xc112f693,Flags: (SYN, ACK).</p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img05.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img05.png" /></a></p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img06.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img06.png" /></a></p>

<p>第三次握手：最后，客户端 192.168.100.191 回应一个 [ACK] 包，此时，Ack = 0xc112f694, Seq = 0x4ce45751, Flags: (ACK).</p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img07.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img07.png" /></a></p>

<p><a data-fancybox="capture-tcp-3-way-handshake" href="../assets/img/post/capture-tcp-3-way-handshake/img08.png"><img src="../assets/img/post/capture-tcp-3-way-handshake/img08.png" /></a></p>

<p>客户端服务器建立连接完成。</p>

<p>之前见过一个 TCP 相关的笑话来着，找不到了:upside_down_face:</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">https://en.wikipedia.org/wiki/Transmission_Control_Protocol</a></li>
</ol>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="network" /><summary type="html"><![CDATA[前言 正文 理论 实践 参考资料 前言]]></summary></entry><entry><title type="html">关于我喜欢 KDE6 壁纸这件事</title><link href="https://zhui.dev/2024-03/kde6-wallpapers" rel="alternate" type="text/html" title="关于我喜欢 KDE6 壁纸这件事" /><published>2024-03-08T00:00:00+08:00</published><updated>2024-03-08T00:00:00+08:00</updated><id>https://zhui.dev/2024-03/kde6-wallpapers</id><content type="html" xml:base="https://zhui.dev/2024-03/kde6-wallpapers"><![CDATA[<p><a data-fancybox="kde6-wallpapers" href="../assets/img/post/kde6-wallpapers/screenshot-from-kde-megarelease6.png"><img src="../assets/img/post/kde6-wallpapers/screenshot-from-kde-megarelease6.png" /></a></p>

<blockquote>
  <p>Screenshot from <a href="https://kde.org/announcements/megarelease/6/">KDE MegaRelease6</a></p>
</blockquote>

<p>KDE6 更新了很多东西，我最喜欢的竟然是新增的壁纸「Scarlet Tree」，它有 light 和 dark 两种风格，还有适用于手机的分辨率。壁纸位于<code class="language-plaintext highlighter-rouge">/usr/share/wallpapers/</code></p>

<p>开始欣赏壁纸（原图）吧！</p>

<blockquote>
  <p>Transform your desktop with the mesmerizing ‘Scarlet Tree’ wallpaper by axo1otl. Capture the dynamic interplay between the sun’s vibrant energy and the comet’s celestial dance.</p>
</blockquote>

<p><a data-fancybox="kde6-wallpapers" href="https://image.zhui.dev/file/1731154981836_5120x2880.png"><img src="https://image.zhui.dev/file/1731154981836_5120x2880.png" /></a></p>

<p><a data-fancybox="kde6-wallpapers" href="https://image.zhui.dev/file/1731154973483_5120x2880.png"><img src="https://image.zhui.dev/file/1731154973483_5120x2880.png" /></a></p>

<p>6.1 更新的「Reef」，这种风格的壁纸太喜欢了。</p>

<p><a data-fancybox="kde6-wallpapers" href="https://image.zhui.dev/file/1731155190919_Reef.jpg"><img src="https://image.zhui.dev/file/1731155190919_Reef.jpg" /></a></p>

<hr />

<p>Btw, 下面这张 Deepin 的壁纸也非常喜欢。</p>

<p><a data-fancybox="kde6-wallpapers" href="https://image.zhui.dev/file/1731155071899_desktop.jpg"><img src="https://image.zhui.dev/file/1731155071899_desktop.jpg" /></a></p>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="misc" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">C 语言中的 unlikely 和 likely</title><link href="https://zhui.dev/2024-02/unlikely-and-likely-in-c" rel="alternate" type="text/html" title="C 语言中的 unlikely 和 likely" /><published>2024-02-29T00:00:00+08:00</published><updated>2024-02-29T00:00:00+08:00</updated><id>https://zhui.dev/2024-02/unlikely-and-likely-in-c</id><content type="html" xml:base="https://zhui.dev/2024-02/unlikely-and-likely-in-c"><![CDATA[<p>今天在这个 <a href="https://github.com/firelzrd/bore-scheduler/commit/2dfae364f6d7ae26eca4ddfafb3764f2525bbaa5">commit</a> 中看到这样一段代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef CONFIG_SCHED_BORE
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sched_bore</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#endif // CONFIG_SCHED_BORE
</span></code></pre></div></div>

<p>这个 <code class="language-plaintext highlighter-rouge">unlikely</code> 让我很疑惑，<code class="language-plaintext highlighter-rouge">if</code> 里面还能这样？然后在网上查了相关资料，了解了其作用。因为这段代码是在<code class="language-plaintext highlighter-rouge">kernel/sched/fair.c</code>中，于是去翻看了 Linux 内核源码，发现很多<code class="language-plaintext highlighter-rouge">if</code>处使用了 <code class="language-plaintext highlighter-rouge">unlikely</code>.</p>

<p><code class="language-plaintext highlighter-rouge">likely()</code>和<code class="language-plaintext highlighter-rouge">unlikely()</code>是一种宏，帮助编译器更好地优化代码的执行路径，以提高程序的性能，<code class="language-plaintext highlighter-rouge">likely()</code>宏用于表示条件为真的可能性较大，而<code class="language-plaintext highlighter-rouge">unlikely()</code>宏则用于表示条件为假的可能性较大。</p>

<p>比如一个判断素数的列子：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
</span>
<span class="kt">int</span> <span class="nf">is_prime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">is_prime</span><span class="p">(</span><span class="n">num</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d is likely a prime number</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d is unlikely a prime number</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>第二十行里，<code class="language-plaintext highlighter-rouge">unlikely(n % i == 0)</code> 表示编译器应该将 <code class="language-plaintext highlighter-rouge">n % i == 0</code> 这个条件判断视为不太可能发生的情况。</p>

<p>如果懂汇编的话可以从汇编层查看对应变化。</p>

<p>既然知道了作用，可不可以通过程序验证是否有优化呢？比如通过时间复杂度高的查找算法在数据级大的样本里查找，然后比较花费的时间，不知道这样是否可以验证。</p>

<p>这是一段查找素数的代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#define MAX_NUMBER 100000000
</span>
<span class="cp">#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
</span>
<span class="kt">void</span> <span class="nf">find_primes_with_unlikely</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">is_prime</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">cpu_time_used</span><span class="p">;</span>

    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_NUMBER</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">is_prime</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">is_prime</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// printf("%d ", i);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
    <span class="n">cpu_time_used</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Find primes with unlikely execution time: %lf ns</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cpu_time_used</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">find_primes_without_unlikely</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">is_prime</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">cpu_time_used</span><span class="p">;</span>

    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_NUMBER</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">is_prime</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">is_prime</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// printf("%d ", i);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
    <span class="n">cpu_time_used</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Find primes without unlikely execution time: %lf ns</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cpu_time_used</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Starting prime search...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  
    <span class="n">find_primes_with_unlikely</span><span class="p">();</span>

    <span class="n">find_primes_without_unlikely</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>最开始用<code class="language-plaintext highlighter-rouge">gettimeofday()</code>函数来获取时间信息，发现几乎没有什么区别，于是换成了 <code class="language-plaintext highlighter-rouge">clock_gettime()</code> 函数来获取纳秒级别的时间信息。</p>

<p>但是吧，这个测试结果不太对，大多数时候是用了<code class="language-plaintext highlighter-rouge">unlikely</code>的花费更多时间…是因为不应该用这样的方式比较？</p>

<p>我又发现了 C++ 也有 <code class="language-plaintext highlighter-rouge">[[likely]]</code> <code class="language-plaintext highlighter-rouge">[[unlikely]]</code>，并且 cppreference 有<a href="https://zh.cppreference.com/w/cpp/language/attributes/likely">示例代码</a>：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span> 
<span class="k">namespace</span> <span class="n">with_attributes</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[[</span><span class="n">likely</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">constexpr</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">[[</span><span class="n">likely</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">cos</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">constexpr</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">precision</span><span class="p">{</span><span class="mi">16LL</span><span class="p">};</span>
        <span class="kt">double</span> <span class="n">y</span><span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span><span class="p">{</span><span class="mi">0LL</span><span class="p">};</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">precision</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">2LL</span><span class="p">)</span> <span class="p">[[</span><span class="n">likely</span><span class="p">]]</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">2LL</span> <span class="o">?</span> <span class="o">-</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace with_attributes</span>
 
<span class="k">namespace</span> <span class="n">no_attributes</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">constexpr</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">cos</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">constexpr</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">precision</span><span class="p">{</span><span class="mi">16LL</span><span class="p">};</span>
        <span class="kt">double</span> <span class="n">y</span><span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span><span class="p">{</span><span class="mi">0LL</span><span class="p">};</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">precision</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">2LL</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">2LL</span> <span class="o">?</span> <span class="o">-</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace no_attributes</span>
 
<span class="kt">double</span> <span class="n">gen_random</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">dis</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dis</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="k">volatile</span> <span class="kt">double</span> <span class="n">sink</span><span class="p">{};</span> <span class="c1">// 确保有副作用</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="p">{</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">)})</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">"x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
            <span class="o">&lt;&lt;</span> <span class="n">with_attributes</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">with_attributes</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">?</span> <span class="s">"equal"</span> <span class="o">:</span> <span class="s">"differ"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
 
    <span class="k">auto</span> <span class="n">benchmark</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">fun</span><span class="p">,</span> <span class="k">auto</span> <span class="n">rem</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">size</span><span class="p">{</span><span class="mi">1ULL</span><span class="p">};</span> <span class="n">size</span> <span class="o">!=</span> <span class="mi">10'000'000ULL</span><span class="p">;</span> <span class="o">++</span><span class="n">size</span><span class="p">)</span>
            <span class="n">sink</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">gen_random</span><span class="p">());</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">diff</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Time: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">diff</span><span class="p">.</span><span class="n">count</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="s">" sec "</span> <span class="o">&lt;&lt;</span> <span class="n">rem</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
    <span class="p">};</span>
 
    <span class="n">benchmark</span><span class="p">(</span><span class="n">with_attributes</span><span class="o">::</span><span class="n">cos</span><span class="p">,</span> <span class="s">"(with attributes)"</span><span class="p">);</span>
    <span class="n">benchmark</span><span class="p">(</span><span class="n">no_attributes</span><span class="o">::</span><span class="n">cos</span><span class="p">,</span> <span class="s">"(without attributes)"</span><span class="p">);</span>
    <span class="n">benchmark</span><span class="p">([](</span><span class="kt">double</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">},</span> <span class="s">"(std::cos)"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是测出来大多数时候也是 <code class="language-plaintext highlighter-rouge">with_attributes</code> 更耗时。也许需要更专业的工具配合正确的场景来进行测试。</p>

<p>参考资料：</p>

<ol>
  <li><a href="https://www.geeksforgeeks.org/branch-prediction-macros-in-gcc/">https://www.geeksforgeeks.org/branch-prediction-macros-in-gcc/</a></li>
  <li><a href="https://stackoverflow.com/questions/109710/how-do-the-likely-unlikely-macros-in-the-linux-kernel-work-and-what-is-their-ben">https://stackoverflow.com/questions/109710/how-do-the-likely-unlikely-macros-in-the-linux-kernel-work-and-what-is-their-ben</a></li>
  <li><a href="https://zh.cppreference.com/w/cpp/language/attributes/likely">https://zh.cppreference.com/w/cpp/language/attributes/likely</a></li>
</ol>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="code" /><summary type="html"><![CDATA[今天在这个 commit 中看到这样一段代码：]]></summary></entry><entry><title type="html">小米社区自动签到/任务</title><link href="https://zhui.dev/2023-11/xiaomi-cn-auto-tasks" rel="alternate" type="text/html" title="小米社区自动签到/任务" /><published>2023-11-08T00:00:00+08:00</published><updated>2023-11-08T00:00:00+08:00</updated><id>https://zhui.dev/2023-11/xiaomi-cn-auto-tasks</id><content type="html" xml:base="https://zhui.dev/2023-11/xiaomi-cn-auto-tasks"><![CDATA[<p>今天<a href="https://www.xiaomi.cn/">小米社区</a>对 Bootloader 解锁权限发布了公告，要求：</p>

<ol>
  <li>通过《解锁资格答题测试》</li>
  <li>社区成长等级达到 5 段</li>
  <li>完成实名认证</li>
</ol>

<p>才能申请解锁，申请一次有效期只有一年，每年最多支持三台设备解锁，解锁等待期为 72 小时。</p>

<p>试着去答了一下《解锁资格答题测试》，很简单，90 多分，都是一些常识和常用命令，但是我社区等级才 2 级，小米社区升级太慢了，又经常忘记签到做任务，于是找到了 <a href="https://github.com/0-8-4/miui-auto-tasks">miui-auto-tasks</a> - 一个自动化完成小米社区任务的脚本。照着它的 <a href="https://github.com/0-8-4/miui-auto-tasks/wiki">wiki</a> 配置，功能全开（<del>用就不要怕</del>）</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">accounts</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">uid</span><span class="pi">:</span> <span class="s">xxxxxxxxx</span>
    <span class="c1"># 账户 ID 非账户用户名或手机号</span>
    <span class="na">password</span><span class="pi">:</span> <span class="s">xxxxxxxxxxxxxxxxxxxxxxxxx</span>
    <span class="c1"># 账户密码或其 MD5 哈希</span>
    <span class="na">user-agent</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Mozilla/5.0</span><span class="nv"> </span><span class="s">(X11;</span><span class="nv"> </span><span class="s">Linux</span><span class="nv"> </span><span class="s">x86_64;</span><span class="nv"> </span><span class="s">rv:121.0)</span><span class="nv"> </span><span class="s">Gecko/20100101</span><span class="nv"> </span><span class="s">Firefox/121.0'</span>
    <span class="c1"># 登录社区时所用浏览器的 User-Agent</span>
    <span class="c1"># 可在此工具查看：https://tool.chinaz.com/useragent</span>
    
    <span class="c1"># 功能开关</span>
    <span class="na">check-in</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="c1"># 社区成长值签到，启用功能意味着你愿意自行承担相关风险</span>
    <span class="na">browse-user-page</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="c1"># 社区浏览个人主页 10 秒，启用功能意味着你愿意自行承担相关风险</span>
    <span class="na">browse-post</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="c1"># 社区浏览帖子 10 秒，启用功能意味着你愿意自行承担相关风险</span>
    <span class="na">thumb-up</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="c1"># 点赞帖子，启用功能意味着你愿意自行承担相关风险</span>
    <span class="na">browse-specialpage</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="c1"># 社区在活动期间可能会出现限时的“浏览指定专题页”任务，启用功能意味着你愿意自行承担相关风险</span>
    <span class="na">board-follow</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="c1"># 社区可能会出现限时的“加入圈子”任务，启用功能意味着你愿意自行承担相关风险</span>
    <span class="na">carrot-pull</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="c1"># 社区拔萝卜，启用功能意味着你愿意自行承担相关风险</span>

<span class="na">logging</span><span class="pi">:</span> <span class="kc">false</span>
<span class="c1"># 归档日志到本地文件</span>
<span class="na">version</span><span class="pi">:</span> <span class="s">v1.6.0</span>
<span class="c1"># config 文件版本号，debug 用</span>

</code></pre></div></div>

<p>用 systemd timer 让它每天执行，先在 <code class="language-plaintext highlighter-rouge">/etc/systemd/user/</code> 创建一个 [Service] 执行 python 程序，</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>MIUI Auto Tasks

<span class="o">[</span>Service]
<span class="nv">Type</span><span class="o">=</span>oneshot
<span class="nv">ExecStart</span><span class="o">=</span>%h/venv/bin/python %h/pytools/miui-auto-tasks/miuitask.py
</code></pre></div></div>

<p>再创建一个 [Timer] 定时执行，</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>Unit]
<span class="nv">Description</span><span class="o">=</span>Run MIUI Auto Tasks Every Day

<span class="o">[</span>Timer]
<span class="nv">OnBootSec</span><span class="o">=</span>3min
<span class="nv">OnCalendar</span><span class="o">=</span><span class="k">*</span>-<span class="k">*</span>-<span class="k">*</span> 12:00:00
<span class="nv">RandomizedDelaySec</span><span class="o">=</span>10min
<span class="nv">Persistent</span><span class="o">=</span><span class="nb">true
</span><span class="nv">Unit</span><span class="o">=</span>miui-auto-tasks.service

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>timers.target
</code></pre></div></div>

<p>用 <code class="language-plaintext highlighter-rouge">systemctl --user enable --now</code> 跑起来，根据我使用电脑的习惯，应该每天都能跑一遍。</p>

<p>参考资料：</p>

<ol>
  <li><a href="https://wiki.archlinux.org/title/Systemd">https://wiki.archlinux.org/title/Systemd</a></li>
  <li><a href="https://wiki.archlinux.org/title/Systemd/Timers">https://wiki.archlinux.org/title/Systemd/Timers</a></li>
</ol>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="misc" /><summary type="html"><![CDATA[今天小米社区对 Bootloader 解锁权限发布了公告，要求：]]></summary></entry><entry><title type="html">在 Arch Linux 上使用 Cloudflare WARP+</title><link href="https://zhui.dev/2023-08/using-cloudflare-warp-plus-on-arch-linux" rel="alternate" type="text/html" title="在 Arch Linux 上使用 Cloudflare WARP+" /><published>2023-08-07T00:00:00+08:00</published><updated>2023-08-07T00:00:00+08:00</updated><id>https://zhui.dev/2023-08/using-cloudflare-warp-plus-on-arch-linux</id><content type="html" xml:base="https://zhui.dev/2023-08/using-cloudflare-warp-plus-on-arch-linux"><![CDATA[<ul id="markdown-toc">
  <li><a href="#安装" id="markdown-toc-安装">安装</a></li>
  <li><a href="#使用" id="markdown-toc-使用">使用</a>    <ul>
      <li><a href="#warp" id="markdown-toc-warp">WARP</a></li>
      <li><a href="#warp-1" id="markdown-toc-warp-1">WARP+</a></li>
      <li><a href="#mode" id="markdown-toc-mode">MODE</a></li>
    </ul>
  </li>
  <li><a href="#使用体验" id="markdown-toc-使用体验">使用体验</a></li>
  <li><a href="#参考资料" id="markdown-toc-参考资料">参考资料</a></li>
</ul>
<p>WARP+ 是 Cloudflare 提供的一项网络加速服务，用于改善互联网连接的速度和安全性。WARP+ 旨在通过优化网络路径，减少延迟，并提供更快的网络连接体验。</p>

<p>这里说的 WARP+ 属于 WARP+ Limited，流量是有限的，通过推广获得免费的服务，但是通过 Warp+ Bot 可以获得 24.59PB 流量，也可以说是 Unlimited 了。而真正的 WARP+ Unlimited 属于付费服务。</p>

<p>关于它们的区别：<a href="https://support.cloudflarewarp.com/hc/en-us/articles/360025731113-What-is-the-difference-between-WARP-WARP-and-WARP-Unlimited">What is the difference between WARP, WARP+, and WARP+ Unlimited?</a></p>

<h2 id="安装">安装</h2>

<p>从 AUR 上或者信得过的第三方仓库安装</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ paru -Ss cloudflare-warp-bin
cachyos/cloudflare-warp-bin 2023.7.40-1 [0B 49.98MiB] [Installed]
    Cloudflare Warp Client
aur/cloudflare-warp-bin 2023.7.40-1 [+41 ~3.15] [Installed]
    Cloudflare Warp Client
</code></pre></div></div>

<h2 id="使用">使用</h2>

<h3 id="warp">WARP</h3>

<p>只需要 3 个命令就能使用 WARP，先启动 <code class="language-plaintext highlighter-rouge">warp-svc.server</code>，第一次使用时需要 <code class="language-plaintext highlighter-rouge">register</code> 进行身份验证，然后 <code class="language-plaintext highlighter-rouge">connect</code> 将启用客户端，创建从设备到 Cloudflare 网络的 WireGuard 隧道。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ sudo systemctl start warp-svc.service // 启动服务

➜ warp-cli register // 进行身份验证
Success

➜ warp-cli connect // 连接
Success
</code></pre></div></div>

<p>此时查看帐户信息可以看到 <code class="language-plaintext highlighter-rouge">Account type: Free</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ warp-cli account
Account type: Free
...
</code></pre></div></div>

<p>通过 cloudflare trace 看到 <code class="language-plaintext highlighter-rouge">warp=on</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ curl https://www.cloudflare.com/cdn-cgi/trace/
...
warp=on
...
</code></pre></div></div>

<p>至此 WARP 就可以使用了。</p>

<h3 id="warp-1">WARP+</h3>

<p>使用  WARP+ 需要去 <a href="https://t.me/generatewarpplusbot">Warp+ Bot</a> 获得 <strong>License Key</strong>，然后 <code class="language-plaintext highlighter-rouge">set-license</code>使用 Key</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❯ warp-cli set-license xxxxxxxx-xxxxxxxx-xxxxxxxx // 得到的 License Key
Success
</code></pre></div></div>

<p>这时查看帐户信息，可以看到 <code class="language-plaintext highlighter-rouge">Account type: Limited</code>，有 <strong>24598562000000000 B = 24.5986 PB</strong> 流量配额，根本用不完。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ warp-cli account                    
Account type: Limited
...
Quota: 24598562000000000
Premium Data: 24598562000000000
</code></pre></div></div>

<p>通过 cloudflare trace 看到 <code class="language-plaintext highlighter-rouge">warp=plus</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ curl https://www.cloudflare.com/cdn-cgi/trace/
...
warp=plus
...
</code></pre></div></div>

<p>至此 WARP+ 就可以使用了。</p>

<h3 id="mode">MODE</h3>

<p>mode 有多种，根据需求设置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ warp-cli set-mode -h
Set the mode

Usage: warp-cli set-mode &lt;MODE&gt;

Arguments:
  &lt;MODE&gt;  [possible values: warp, doh, warp+doh, dot, warp+dot, proxy, tunnel_only]

Options:
  -h, --help  Print help
</code></pre></div></div>

<p>我需要 <code class="language-plaintext highlighter-rouge">proxy</code> 模式</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ warp-cli set-mode proxy // 默认端口是 40000, 127.0.0.1:40000
Success
</code></pre></div></div>

<p>查看一下 ip 信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ curl ipinfo.io -x socks5://127.0.0.1:40000
{
  "ip": "104.28.xxx.xxx",
  "city": "Fremont",
  "region": "California",
  "country": "US",
  "loc": "xx.5483,-xxx.9886",
  "org": "AS13335 Cloudflare, Inc.",
  "postal": "94536",
  "timezone": "America/Los_Angeles",
  "readme": "https://ipinfo.io/missingauth"
}
</code></pre></div></div>

<p>更多命令<code class="language-plaintext highlighter-rouge">warp-cli --help</code></p>

<h2 id="使用体验">使用体验</h2>

<p>日用勉强，更适合备用。</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://developers.cloudflare.com/warp-client/get-started/linux/">https://developers.cloudflare.com/warp-client/get-started/linux/</a></li>
</ol>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="linux" /><category term="tool" /><summary type="html"><![CDATA[安装 使用 WARP WARP+ MODE 使用体验 参考资料 WARP+ 是 Cloudflare 提供的一项网络加速服务，用于改善互联网连接的速度和安全性。WARP+ 旨在通过优化网络路径，减少延迟，并提供更快的网络连接体验。]]></summary></entry><entry><title type="html">如何播放阿里云盘原始视频文件</title><link href="https://zhui.dev/2023-07/how-to-play-aliyundrive-original-video-file" rel="alternate" type="text/html" title="如何播放阿里云盘原始视频文件" /><published>2023-07-21T00:00:00+08:00</published><updated>2023-07-21T00:00:00+08:00</updated><id>https://zhui.dev/2023-07/how-to-play-aliyundrive-original-video-file</id><content type="html" xml:base="https://zhui.dev/2023-07/how-to-play-aliyundrive-original-video-file"><![CDATA[<p>原始视频文件清晰度有 1080p/2k/4k , 但在阿里云盘官方软件没会员只有 480p，这谁受得了？为了能播放最高清晰度的视频我找到了<a href="https://github.com/liupan1890/aliyunpan">阿里云盘小白羊版</a>，通过 mpv 等播放器能够播放原始清晰度。最近发现原版没人维护，有些 bug 很难受，又找到了 <a href="https://github.com/odomu/aliyunpan">fork 版 1</a>和 <a href="https://github.com/gaozhangmin/aliyunpan">fork 版 2</a>.</p>

<p>虽然小白羊版在电脑上能播放原始文件的清晰度，但是手机上却没找到这种工具。</p>

<p>直到遇到了 <a href="https://github.com/alist-org/alist">alist</a> – A file list program that supports multiple storages, powered by Gin and Solidjs. / 一个支持多存储的文件列表程序，使用 Gin 和 Solidjs。</p>

<p>在本地启动后，家里任何一台设备都能访问，简直太棒啦，结束了 2k 屏看 480p 的日子。</p>

<p>家里部署好了，又想在外面也能用上，在外面用的话那不是得整一台服务器，虽然内网穿透也可以，但我试过了，有点卡，而且长时间出门我习惯给电脑睡眠/关机。</p>

<p>算了，先这样吧。</p>

<hr />

<p>用了一段时间后，我发现在手机上跑 alist 更舒服，可以完美解决我的所有问题，家里/外面都能用了，还省了服务器的钱。</p>

<p>当然，alist 的功能不止于此。</p>]]></content><author><name>Mr. Error 追</name><email>error@zhui.dev</email></author><category term="tool" /><summary type="html"><![CDATA[原始视频文件清晰度有 1080p/2k/4k , 但在阿里云盘官方软件没会员只有 480p，这谁受得了？为了能播放最高清晰度的视频我找到了阿里云盘小白羊版，通过 mpv 等播放器能够播放原始清晰度。最近发现原版没人维护，有些 bug 很难受，又找到了 fork 版 1和 fork 版 2.]]></summary></entry></feed>